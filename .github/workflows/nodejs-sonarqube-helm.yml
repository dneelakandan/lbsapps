name: Node.js CI/CD

on:
  push:
    branches:
      - main
  workflow_dispatch:

concurrency:
  group: aks-deploy
  cancel-in-progress: true

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Login to ACR
        run: az acr login --name ${{ secrets.ACR_NAME }}

      - name: Install dependencies and run SonarQube scan for appointment-service
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          cd services/appointment-service
          npm install
          npx sonar-scanner \
            -Dsonar.projectKey=appointment-service \
            -Dsonar.sources=. \
            -Dsonar.host.url=${{ secrets.SONAR_HOST_URL }} \
            -Dsonar.login=$SONAR_TOKEN

      - name: Install dependencies and run SonarQube scan for patient-service
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          cd services/patient-service
          npm install
          npx sonar-scanner \
            -Dsonar.projectKey=patient-service \
            -Dsonar.sources=. \
            -Dsonar.host.url=${{ secrets.SONAR_HOST_URL }} \
            -Dsonar.login=$SONAR_TOKEN

      - name: Build and push Docker image for appointment-service
        run: |
          docker build -t ${{ secrets.ACR_NAME }}.azurecr.io/appointment-service:latest ./services/appointment-service
          docker push ${{ secrets.ACR_NAME }}.azurecr.io/appointment-service:latest

      - name: Build and push Docker image for patient-service
        run: |
          docker build -t ${{ secrets.ACR_NAME }}.azurecr.io/patient-service:latest ./services/patient-service
          docker push ${{ secrets.ACR_NAME }}.azurecr.io/patient-service:latest

# Simplified Trivy scan without CodeQL upload
  #trivy-scan:
  #  runs-on: ubuntu-latest
  #  needs: build-and-deploy
   # strategy:
   #   matrix:
   #     service: [patient-service, appointment-service]
   # steps:
   #   - name: Azure Login
   #     uses: azure/login@v1
   #     with:
   #       creds: ${{ secrets.AZURE_CREDENTIALS }}

   #   - name: Login to ACR
   #     run: echo "${{ secrets.AZURE_CLIENT_SECRET }}" | docker login ${{ secrets.ACR_NAME }}.azurecr.io -u "${{ secrets.AZURE_CLIENT_ID }}" --password-stdin
      
      
      - name: Pull appointment-service image from ACR
        run: docker pull ${{ secrets.ACR_NAME }}.azurecr.io/appointment-service:latest

      - name: Run Trivy vulnerability scanner appointment-service
        uses: aquasecurity/trivy-action@0.24.0
        with:
          image-ref: '${{ secrets.ACR_NAME }}.azurecr.io/appointment-service:latest'
          format: 'table'
          output: 'trivy-results-appointment-service.txt'
          severity: 'CRITICAL,HIGH'
          exit-code: 0  
      
         

      - name: List files
        run: ls -l

      - name: Upload Trivy results as artifact for appointment-service
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: trivy-results-appointment-service
          path: trivy-results-appointment-service.txt
          retention-days: 30

      - name: Pull patient-service image from ACR
        run: docker pull ${{ secrets.ACR_NAME }}.azurecr.io/patient-service:latest

      - name: Run Trivy vulnerability scanner appointment-service
        uses: aquasecurity/trivy-action@0.24.0
        with:
          image-ref: '${{ secrets.ACR_NAME }}.azurecr.io/patient-service:latest'
          format: 'table'
          output: 'trivy-results-patient-service.txt'
          severity: 'CRITICAL,HIGH'
          exit-code: 0  
    
 
      - name: List files
        run: ls -l

      - name: Upload Trivy results as artifact for patient-service
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: trivy-results-patient-service
          path: trivy-results-patient-service.txt
          retention-days: 30




      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Azure Login (for AKS)
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set AKS context
        run: az aks get-credentials --resource-group ${{ secrets.AKS_RESOURCE_GRP }} --name ${{ secrets.AKS_CLUSTER }}

      - name: Install Helm
        run: |
          curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
      - name: Clean up existing namespace with retry logic
        run: |
          # Function to delete namespace with retries
          delete_namespace() {
            local namespace=$1
            local max_retries=3
            local retry_count=0
            while [ $retry_count -lt $max_retries ]; do
              if kubectl get namespace "$namespace" >/dev/null 2>&1; then
                echo "Namespace $namespace exists, attempting to delete (attempt $((retry_count + 1))/$max_retries)..."
                kubectl delete namespace "$namespace" --ignore-not-found=true
                # Wait for deletion with timeout
                if kubectl wait --for=delete namespace/"$namespace" --timeout=60s 2>/dev/null; then
                  echo "Namespace $namespace successfully deleted"
                  return 0
                else
                  echo "Namespace deletion still in progress, waiting..."
                  sleep 10
                fi

              else
                echo "Namespace $namespace does not exist"
                return 0
             fi
             retry_count=$((retry_count + 1))
           done

           echo "Warning: Could not fully delete namespace $namespace after $max_retries attempts"
           return 1

          }

          # Delete the namespace
          delete_namespace "healthcare" || true
          # Additional wait to ensure namespace is gone
          echo "Waiting for namespace cleanup to complete..."
          sleep 15

      - name: Create namespace with Helm labels
        run: |
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: Namespace
          metadata:
            name: healthcare
            labels:
              app.kubernetes.io/managed-by: Helm
            annotations:
              meta.helm.sh/release-name: healthcare
              meta.helm.sh/release-namespace: healthcare
          EOF

      - name: Create ACR pull secret
        run: |
          kubectl create secret docker-registry acr-secret \
            --namespace healthcare \
            --docker-server=${{ secrets.ACR_NAME }}.azurecr.io \
            --docker-username=${{ secrets.AZURE_CLIENT_ID }} \
            --docker-password=${{ secrets.AZURE_CLIENT_SECRET }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy to AKS using Helm
        run: |
          cd helm
          
          MAX_RETRIES=5
          RETRY_DELAY=30
          COUNT=0

          RELEASE_NAME=healthcare
          NAMESPACE=healthcare

          # Check for pending operations
          STATUS=$(helm status $RELEASE_NAME --namespace $NAMESPACE 2>&1 || true)
          if echo "$STATUS" | grep -q "pending"; then
            echo "Helm release is in a pending state. Cleaning up..."
            kubectl delete secret -n $NAMESPACE sh.helm.release.v1.$RELEASE_NAME.v1 || true
            helm uninstall $RELEASE_NAME --namespace $NAMESPACE || true
            sleep 10
          fi

          until helm upgrade --install healthcare . \
            --namespace healthcare \
            --create-namespace \
            --wait \
            --timeout 15m \
            --set global.environment=dev \
            --set image.registry=${{ secrets.ACR_NAME }}.azurecr.io \
            --set patientService.image=patient-service \
            --set patientService.tag=latest \
            --set appointmentService.image=appointment-service \
            --set appointmentService.tag=latest \
            --values values-dev.yaml
          do
            COUNT=$((COUNT + 1))
            if [ $COUNT -ge $MAX_RETRIES ]; then
              echo "Helm upgrade failed after $MAX_RETRIES attempts."
              exit 1
            fi

            echo "Helm upgrade failed. Retrying in $RETRY_DELAY seconds... (Attempt $COUNT/$MAX_RETRIES)"
            sleep $RETRY_DELAY
          done
      - name: Verify deployment
        run: |
          echo "=== Deployment Verification ==="
          kubectl get pods -n healthcare -o wide
          echo ""
          kubectl get services -n healthcare
          echo ""
          kubectl get ingress -n healthcare
          echo ""
          kubectl get hpa -n healthcare
 
      - name: Run smoke tests
        run: |
          echo "checking services to be ready"
          kubectl wait --for=condition=ready pod -l app=patientservice -n healthcare --timeout=300s
          kubectl wait --for=condition=ready pod -l app=appointmentservice -n healthcare --timeout=300s
          echo "Testing production health endpoints..."
          kubectl run -it --rm --restart=Never test-patient --image=curlimages/curl --namespace=healthcare --command -- curl -s -f http://patientservice:3000/health && echo "Patient service: HEALTHY" || echo "Patient service: UNHEALTHY"
          kubectl run -it --rm --restart=Never test-appointment --image=curlimages/curl --namespace=healthcare --command -- curl -s -f http://appointmentservice:3001/health && echo "Appointment service: HEALTHY" || echo "Appointment service: UNHEALTHY"
          echo "Production deployment verified"    
